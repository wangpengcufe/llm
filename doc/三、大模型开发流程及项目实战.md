# 一、大模型开发整理流程

## 1.1、什么是大模型开发

**我们将开发以大语言模型为功能核心、通过大语言模型的强大理解能力和生成能力、结合特殊的数据或业务逻辑来提供独特功能的应用称为大模型开发。**

开发大模型相关应用，其技术核心点虽然在大语言模型上，但一般通过调用 API 或开源模型来实现核心的理解与生成，通过 Prompt Enginnering 来实现大语言模型的控制，因此，虽然大模型是深度学习领域的集大成之作，大模型开发却更多是一个工程问题。

在大模型开发中，我们一般不会去大幅度改动模型，而是将大模型作为一个调用工具，通过 Prompt Engineering、数据工程、业务逻辑分解等手段来充分发挥大模型能力，适配应用任务，而不会将精力聚焦在优化模型本身上。

![大语言模型开发要素](https://upload-images.jianshu.io/upload_images/7289495-83b355df9b7d44e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


大模型开发与传统的AI 开发在整体思路上有着较大的不同。

- 传统AI 开发：首先需要将复杂的业务逻辑依次拆解，对于每个子业务构造训练数据与验证数据，对于每个子业务训练优化模型，最后形成完整的模型链路来解决整个业务逻辑。
- 大模型开发：用 Prompt Engineering 来替代子模型的训练调优，通过 Prompt 链路组合来实现业务逻辑，用一个通用大模型 + 若干业务 Prompt 来解决任务，从而将传统的模型训练调优转变成了更简单、轻松、低成本的 Prompt 设计调优。

大模型开发与传统 AI 开发在评估思路上也有了质的差异。

- 传统 AI 开发：构造训练集、测试集、验证集，通过在训练集上训练模型、在测试集上调优模型、在验证集上最终验证模型效果来实现性能的评估。
- 大模型开发：更敏捷、灵活，不会在初期显式地确定训练集、验证集，而是直接从实际业务需求出发构造小批量验证集，设计合理 Prompt 来满足验证集效果。然后，不断从业务逻辑中收集当下 Prompt 的 Bad Case，并将 Bad Case 加入到验证集中，针对性优化 Prompt，最后实现较好的泛化效果。

![传统AI评估](https://upload-images.jianshu.io/upload_images/7289495-deeda47f0788a4b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![LLM评估](https://upload-images.jianshu.io/upload_images/7289495-070918a0a05c6e98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 1.2、大模型开发整体流程

![大模型开发流程](https://upload-images.jianshu.io/upload_images/7289495-0211742d16d1674d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 1.2.1、设计
包括确定目标，设计功能。
**确定目标：**在进行开发前，需要确定开发的目标，即要开发的应用的应用场景、目标人群、核心价值。一般应先设定最小化目标，从构建一个 mvp（最小可行性产品）开始，逐步进行完善和优化。

**设计功能：**确定开发目标后，设计本应用所要提供的功能，首先确定应用的核心功能，然后延展设计核心功能的上下游功能；例如，想打造一款个人知识库助手，核心功能就是结合个人知识库内容进行问题的回答，上游功能——用户上传知识库、下游功能——用户手动纠正模型回答，就是子功能。

### 1.2.2、架构搭建

**搭建整体架构：**搭建项目的整体架构，实现从用户输入到应用输出的全流程贯通。包括搭建整体架构和搭建数据库。

目前，绝大部分大模型应用都是采用的特定数据库+ Prompt + 通用大模型的架构。

推荐基于 LangChain 框架进行开发。LangChain 提供了 Chain、Tool 等架构的实现，可以基于 LangChain 进行个性化定制，实现从用户输入到数据库再到大模型最后输出的整体架构连接。

**搭建数据库：** 大模型应用需要进行向量语义检索，一般使用诸如 chroma 的向量数据库。搭建数据库需要收集数据并进行预处理，再向量化存储到数据库中。数据预处理一般包括从多种格式向纯文本的转化，例如 pdf、markdown、html、音视频等，以及对错误数据、异常数据、脏数据进行清洗。完成预处理后，需要进行切片、向量化构建出个性化数据库。

### 1.2.3、Prompt Engineering

明确 Prompt 设计的一般原则及技巧，构建出一个来源于实际业务的小型验证集，基于小型验证集设计满足基本要求、具备基本能力的 Prompt。

优质的 Prompt 对大模型能力具有极大影响，需要逐步迭代构建优质的 Prompt Engineering 来提升应用性能。

### 1.2.4、验证迭代

验证迭代在大模型开发中是极其重要的一步，指通过不断发现 Bad Case 并针对性改进 Prompt Engineering 来提升系统效果、应对边界情况。在完成上一步的初始化 Prompt 设计后，应该进行实际业务测试，探讨边界情况，找到 Bad Case，并针对性分析 Prompt 存在的问题，从而不断迭代优化，直到达到一个较为稳定、可以基本实现目标的 Prompt 版本。

### 1.2.5、前后端搭建

完成 Prompt Engineering 及其迭代优化之后，就完成了应用的核心功能，可以充分发挥大语言模型的强大能力。接下来搭建前后端，设计产品页面，让应用上线成为产品。

两种快速开发 Demo 的框架：Gradio 和 Streamlit，可以帮助个体开发者迅速搭建可视化页面实现 Demo 上线。

在完成前后端搭建之后，应用就可以上线体验了。接下来就需要进行长期的用户体验跟踪，记录 Bad Case 与用户负反馈，再针对性进行优化即可。

# 二、项目流程简析

基于个人知识库的问答助手介绍项目流程。

**项目原理：**项目原理如下图所示，过程包括加载本地文档 -> 读取文本 -> 文本分割 -> 文本向量化 -> question向量化 -> 在文本向量中匹配出与问句向量最相似的 top k个 -> 匹配出的文本作为上下文和问题一起添加到 prompt中 -> 提交给 LLM生成回答。
![项目原理](https://upload-images.jianshu.io/upload_images/7289495-359139df8c22894f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


## 2.1、项目规划与需求分析

1、**项目目标：**基于个人知识库的问答助手

2、**核心功能：**
1、上传文档、创建知识库；
2、选择知识库，检索用户提问的知识片段；
3、提供知识片段与提问，获取大模型回答；
4、流式回复；
5、历史对话记录

3、**确定技术架构和工具：**

1、LangChain框架
2、Chroma知识库
3、大模型使用 GPT、科大讯飞的星火大模型、文心一言、GLM 等
4、前后端使用 Gradio 和 Streamlit。

## 2.2、数据准备与向量知识库构建

### 2.2.1、收集和整理用户提供的文档

用户常用文档格式有 pdf、txt、doc 等，首先使用工具读取文本，通常使用 langchain 的文档加载器模块，也可以使用 python 比较成熟的包进行读取。

由于目前大模型使用 token 的限制，需要对读取的文本进行切分，将较长的文本切分为较小的文本，这时一段文本就是一个单位的知识。

### 2.2.2、将文档词向量化

使用文本嵌入(Embeddings)对分割后的文档进行向量化，使语义相似的文本片段具有接近的向量表示。然后，存入向量数据库，这个流程正是创建 索引(index) 的过程。

向量数据库对各文档片段进行索引，支持快速检索。这样，当用户提出问题时，可以先将问题转换为向量，在数据库中快速找到语义最相关的文档片段。然后将这些文档片段与问题一起传递给语言模型，生成回答。

### 2.2.3、将向量化后的文档导入Chroma知识库，建立知识库索引

Chroma 向量库轻量级且数据存储在内存中，非常容易启动和开始使用。

用户知识库内容经过 embedding 存入向量知识库，然后用户每一次提问也会经过 embedding，利用向量相关性算法（例如余弦算法）找到最匹配的几个知识库片段，将这些知识库片段作为上下文，与用户问题一起作为 prompt 提交给 LLM 回答。

## 2.3、大模型集成与API连接

- 集成GPT、星火、文心、GLM 等大模型，配置 API 连接。
- 编写代码，实现与大模型 API 的交互，以便获取问题答案。

## 2.4、核心功能实现

- 构建 Prompt Engineering，实现大模型回答功能，根据用户提问和知识库内容生成回答。
- 实现流式回复，允许用户进行多轮对话。
- 添加历史对话记录功能，保存用户与助手的交互历史。

## 2.5、核心功能迭代优化

- 进行验证评估，收集 Bad Case。
- 根据 Bad Case 迭代优化核心功能实现。

## 2.6、前端与用户交互界面开发

- 使用 Gradio 和 Streamlit 搭建前端界面。
- 实现用户上传文档、创建知识库的功能。
- 设计用户界面，包括问题输入、知识库选择、历史记录展示等。

## 2.7、部署测试与上线

- 部署问答助手到服务器或云平台，确保可在互联网上访问。
- 进行生产环境测试，确保系统稳定。
- 上线并向用户发布。

## 2.8、维护与持续改进

- 监测系统性能和用户反馈，及时处理问题。
- 定期更新知识库，添加新的文档和信息。
- 收集用户需求，进行系统改进和功能扩展。

# 三、项目架构简析

## 3.1、整体架构

搭建一个基于大模型的个人知识库助手，基于 LangChain 框架搭建，核心技术包括 LLM API 调用、向量数据库、检索问答链等。项目整体架构如下：

![项目架构](https://upload-images.jianshu.io/upload_images/7289495-55de21e20ece9117.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

项目从底向上依次分为 LLM 层、数据层、数据库层、应用层与服务层：

### 3.1.1、LLM 层
基于四种流行 LLM API （OpenAI-ChatGPT、百度文心、讯飞星火、智谱GLM）进行了 LLM 调用封装，支持用户以统一的入口、方式来访问不同的模型，支持随时进行模型的切换；

在 LLM 层，构建了一个 Self_LLM 基类，基类定义了所有 API 的一些共同参数（如 API_Key，temperature 等）；在该基类基础上继承实现了上述四种 LLM API 的自定义 LLM。四种 LLM 的原生 API 封装在了统一的 get_completion 函数中。

### 3.1.2、数据层 
包括个人知识库的源数据（包括 pdf、txt、md 等）以及 Embedding API，源数据经过 Embedding 处理可以被向量数据库使用；

###  3.1.3、数据库层
基于个人知识库源数据搭建的向量数据库，本项目中选择了 Chroma。在该层实现了源数据处理、创建向量数据库的方法;

###  3.1.4、应用层 
应用层封装了整个项目的全部核心功能。基于 LangChain 提供的检索问答链基类进行了进一步封装，支持通过 model 参数进行不同模型切换以及便捷实现基于数据库的检索问答。

实现了两个检索问答链，分别是有历史记录的 Chat_QA_Chain 和没有历史记录的 QA_Chain；

###  3.1.5、服务层
 实现了 Gradio 搭建 Demo 与 FastAPI 组建 API 两种方式来支持本项目的服务访问。

## 3.2、代码结构

```
-project
    -readme.md 项目说明
    -requirements.txt 使用依赖包的版本 
    -llm LLM调用封装
        -self_llm.py 自定义 LLM 基类
        -wenxin_llm.py 自定义百度文心 LLM
        -spark_llm.py 自定义讯飞星火 LLM
        -zhipuai_llm.py 自定义智谱AI LLM
        -call_llm.py 将各个 LLM 的原生接口封装在一起
        -test.ipynb 使用示例
    -embedding embedding调用封装
        -zhipuai_embedding.py 自定义智谱AI embedding
        -call_embedding.py 调用 embedding 模型 
    -data 源数据路径
    -database 数据库层封装
        -create_db.py 处理源数据及初始化数据库封装
    -qa_chain 应用层封装
        -qa_chain.py 封装检索问答链，返回一个检索问答链对象
        -chat_qa_chian.py：封装对话检索链，返回一个带有历史记录的对话检索链对象
        -get_vectordb.py 返回向量数据库对象
        -model_to_llm.py 调用模型
        -test.ipynb 使用示例
    -serve 服务层封装
        -run_gradio.py 启动 Gradio 界面
        -api.py 封装 FastAPI
        -run_api.sh 启动 API
        -test.ipynb 使用示例

```

## 3.3、项目逻辑

1、用户：可以通过 run_gradio 或者 run_api 启动整个服务；
2、服务层调用 qa_chain.py 或 chat_qa_chain 实例化对话检索链对象，实现全部核心功能；
3、服务层和应用层都可以调用、切换 prompt_template.py 中的 prompt 模板来实现 prompt 的迭代；
4、也可以直接调用 call_llm 中的 get_completion 函数来实现不使用数据库的 LLM；
5、应用层调用已存在的数据库和 llm 中的自定义 LLM 来构建检索链；
6、如果数据库不存在，应用层调用 create_db.py 创建数据库，该脚本可以使用 openai embedding 也可以使用 embedding.py 中的自定义 embedding


